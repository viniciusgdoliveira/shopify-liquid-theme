{% comment %}
  CSS Loading Optimization Snippet
  
  This snippet implements:
  1. Critical CSS inlining (already in critical.css)
  2. Async loading of non-critical CSS with bundling
  3. Preloading of critical resources
  4. Performance monitoring
  5. Fallback for non-JS users
  6. CSS bundling for better performance
{% endcomment %}

{% comment %} Preload critical fonts {% endcomment %}
{% if settings.font_primary %}
  {{ settings.font_primary | font_url | preload_tag: as: 'font', type: 'font/woff2', crossorigin: true }}
{% endif %}

{% comment %} Preload critical images {% endcomment %}
{% if settings.logo %}
  {{ settings.logo | image_url: width: 200 | preload_tag: as: 'image' }}
{% endif %}

{% comment %} Async CSS Loading Script with Bundling {% endcomment %}
<script>
(function() {
  'use strict';
  
  // CSS files to load asynchronously (non-critical) - bundled for better performance
  const asyncCSSBundle = [
    '{{ "collection.css" | asset_url }}',
    '{{ "product.css" | asset_url }}',
    '{{ "cart.css" | asset_url }}',
    '{{ "utilities.css" | asset_url }}',
    '{{ "components.css" | asset_url }}'
  ];
  
  // CSS files that are critical and should load immediately
  const criticalCSS = [
    '{{ "v-design-system.css" | asset_url }}',
    '{{ "base.css" | asset_url }}',
    '{{ "header.css" | asset_url }}'
  ];
  
  // Function to load CSS asynchronously with bundling
  function loadCSSBundle(cssFiles) {
    return new Promise((resolve, reject) => {
      let loadedCount = 0;
      const totalFiles = cssFiles.length;
      const errors = [];
      
      cssFiles.forEach((href, index) => {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = href;
        link.media = 'print'; // Load as print media first to avoid render blocking
        
        link.onload = () => {
          link.media = 'all'; // Switch to all media after load
          loadedCount++;
          
          if (loadedCount === totalFiles) {
            resolve({ loaded: loadedCount, total: totalFiles, errors });
          }
        };
        
        link.onerror = () => {
          errors.push({ file: href, index });
          loadedCount++;
          
          if (loadedCount === totalFiles) {
            resolve({ loaded: loadedCount, total: totalFiles, errors });
          }
        };
        
        document.head.appendChild(link);
      });
    });
  }
  
  // Function to preload CSS
  function preloadCSS(href) {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.href = href;
    link.as = 'style';
    link.onload = function() {
      this.rel = 'stylesheet';
    };
    document.head.appendChild(link);
  }
  
  // Load critical CSS immediately
  criticalCSS.forEach(href => {
    preloadCSS(href);
  });
  
  // Load async CSS bundle after DOM is ready
  function loadAsyncCSSBundle() {
    loadCSSBundle(asyncCSSBundle).then(result => {
      // Log any failed CSS loads for debugging
      if (result.errors.length > 0) {
        console.warn('Some CSS files failed to load:', result.errors);
      }
      
      // Dispatch event when all CSS is loaded
      document.dispatchEvent(new CustomEvent('css:loaded', {
        detail: { 
          loaded: result.loaded,
          total: result.total,
          errors: result.errors.length
        }
      }));
    });
  }
  
  // Load async CSS when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadAsyncCSSBundle);
  } else {
    loadAsyncCSSBundle();
  }
  
  // Performance monitoring
  if ('performance' in window && 'mark' in performance) {
    performance.mark('css-loading-start');
    
    document.addEventListener('css:loaded', () => {
      performance.mark('css-loading-end');
      performance.measure('css-loading-time', 'css-loading-start', 'css-loading-end');
      
      const measure = performance.getEntriesByName('css-loading-time')[0];
      if (measure && measure.duration > 1000) {
        console.warn(`CSS loading took ${measure.duration.toFixed(2)}ms - consider optimization`);
      }
    });
  }
  
  // Fallback for users without JavaScript
  // Add noscript tags for critical CSS
  const noscript = document.createElement('noscript');
  noscript.innerHTML = `
    <link rel="stylesheet" href="{{ 'collection.css' | asset_url }}">
    <link rel="stylesheet" href="{{ 'product.css' | asset_url }}">
    <link rel="stylesheet" href="{{ 'cart.css' | asset_url }}">
    <link rel="stylesheet" href="{{ 'utilities.css' | asset_url }}">
    <link rel="stylesheet" href="{{ 'components.css' | asset_url }}">
  `;
  document.head.appendChild(noscript);
  
})();
</script>

{% comment %} CSS Loading Performance Monitoring {% endcomment %}
<script>
// Monitor Core Web Vitals for CSS loading impact
if ('web-vital' in window || typeof import !== 'undefined') {
  // This would integrate with web-vitals library if available
  // For now, we'll use basic performance monitoring
  
  function measureCLS() {
    let clsValue = 0;
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
    });
    
    observer.observe({ entryTypes: ['layout-shift'] });
    
    return clsValue;
  }
  
  // Monitor layout shifts that might be caused by CSS loading
  if ('PerformanceObserver' in window) {
    const cls = measureCLS();
    
    // Report high CLS values
    if (cls > 0.1) {
      console.warn(`High Cumulative Layout Shift detected: ${cls.toFixed(3)}`);
    }
  }
}
</script>
